# Cursor 開発ガイドライン - Project Template

## 基本方針

- **段階的実装**: タスクを小さな単位に分割して段階的に実装する
- **確認ベース**: 各ステップで動作確認を行ってから次に進む
- **単一責任**: 1 つのタスクに集中し、複数機能を同時実装しない

## PR 作成・/dev コマンド実行時の必須ルール

- すべての修正は、ビルド・テストが通る状態で、必ず差分が発生する PR として提出すること。
- PR 作成後は、必須チェック（GitHub Actions 等）が完了し、pending や失敗がないことを確認すること。
- コマンドや引数の記法は公式ドキュメントに従うこと。
- チェックが pending の場合は、空コミット追加や PR 再オープンで再実行を試みること。
- PRがmainブランチ等にマージされたら、作業ブランチ（feature/やfix/など）は速やかに削除すること。削除はGitHubのWeb UIまたはローカルGitコマンド（`git push origin --delete [branch名]`）で行う。
- 緊急修正や検証用でブランチを残す場合は、理由を明記して管理してください。

## 🚨 重要：自動PR作成の一時停止について

**Cursor Webのバックエンドでインシデントが断続的に発生しているため、自動でのPR作成は一時的に停止しています。**

- `/pr` コマンドは自動PR作成を行わず、手動でPRを作成できるリンクを提供します
- `/dev` フルワークフローも自動PR作成を行わず、手動作成リンクを提供します
- 安全のため、PRは必ず手動で作成・確認してください

## 実装の進め方

1. **事前確認**: `.claude/project-rules.md` と `.claude/context.md` を必ず参照
2. **小単位実装**: 1 つの機能につき 1 つのファイルまたはコンポーネントに集中
3. **段階確認**: 実装前に具体的な手順を 3-5 ステップに分割して提示
4. **動作確認**: 各段階で「次のステップに進みますか？」と確認を求める
5. **エラー対応**: エラーが発生した場合は、その箇所のみを修正

## タスク分割の例

### ❌ 悪い例

「認証機能を完全に実装してください」

### ✅ 良い例

「認証機能を以下の順序で段階的に実装してください：

1. ログインフォームの UI のみ（バリデーションなし）
2. フォームバリデーション機能の追加
3. Firebase Auth 連携の実装
   各段階で動作確認をしてから次に進んでください。」

## 禁止事項

- 複数ファイルの同時大幅変更
- 未確認のまま次の機能に進む
- 全体的なリファクタリングを一度に行う
- 任意の値（arbitrary values）の使用
- 標準 Tailwind クラス（text-gray-500 等）の使用

## 推奨する作業単位

- UI コンポーネント 1 つずつ
- API 機能 1 つずつ
- バグ修正 1 つずつ
- テスト追加 1 つずつ

## 確認必須項目

- [ ] TypeScript 型エラーなし
- [ ] ESLint/Prettier 準拠
- [ ] カスタムデザイントークンのみ使用
- [ ] アクセシビリティ対応確認
- [ ] レスポンシブ対応確認

## コマンド優先順位

1. `.claude/commands/design/figma-to-component.md` - 新規コンポーネント作成
2. `.claude/commands/design/refactor-safe.md` - 既存コンポーネント改修
3. `.claude/commands/development/create-feature-complete.md` - 機能実装
4. `.claude/commands/development/review-comprehensive.md` - 品質確認

## ショートカットコマンド

- **"/step"** = step-by-step-implementation.md に従って段階的実装
- **"/figma"** = figma-to-component.md に従ってコンポーネント作成
- **"/refactor"** = refactor-safe.md に従って安全リファクタリング
- **"/review"** = review-comprehensive.md に従って品質確認
- **"/feature"** = create-feature-complete.md に従って機能実装
- **"/test"** = test-all.md に従ってテスト実行

### Git 操作コマンド

- **"/commit"** = 変更をコミット（適切なコミットメッセージ付き）
- **"/push"** = 現在のブランチをリモートにプッシュ
- **"/pr"** = 手動でPRを作成するためのリンクを提供（自動作成は一時停止中）
- **"/deploy"** = deploy-production.md に従って本番デプロイ

### フルワークフローコマンド

- **"/dev"** = 開発ワークフロー（ブランチ作成 → 実装 → 手動PR作成リンク提供）
- **"/quick"** = 簡易ワークフロー（現在ブランチで実装 → コミット → プッシュ）
- **"/hotfix"** = 緊急修正ワークフロー（hotfix/ブランチ → 修正 → 手動PR作成リンク提供）

## 使用例

User: "/step ログイン機能を実装"
→ step-by-step-implementation.md に従って、ログイン機能を段階的に実装

User: "/figma ボタンコンポーネント"  
→ figma-to-component.md に従って、ボタンコンポーネントを作成

User: "/commit"
→ 変更を分析して適切なメッセージでコミット

User: "/commit ログイン機能を追加"  
→ 指定されたメッセージでコミット

User: "/push"
→ 現在のブランチをリモートにプッシュ

User: "/pr ログイン機能の実装"
→ 手動でPRを作成するためのリンクを提供（自動作成は一時停止中）

User: "/commit && /push && /pr"
→ コミット → プッシュ → 手動PR作成リンク提供

## Git 操作の詳細動作

### /commit の動作

1. `git status` で変更を確認
2. 変更内容を分析して適切なコミットメッセージを生成
3. `git add .` で全変更をステージング
4. `git commit -m "生成されたメッセージ"` で実行

### /push の動作

1. 現在のブランチを確認
2. `git push origin [current-branch]` を実行
3. プッシュ結果を報告

### /pr の動作

**⚠️ 注意：自動PR作成は一時停止中**

1. 現在のブランチを確認
2. 変更内容を分析してPR説明文を生成
3. 手動でPRを作成するためのGitHubリンクを提供
4. PR作成手順を案内

## フルワークフロー詳細

### /dev の動作フロー

1. **ブランチ確認**: `git status` と `git branch` で現在状況確認
2. **ブランチ作成**: `feature/[機能名]` または `fix/[修正名]` ブランチを作成
3. **段階的実装**: step-by-step-implementation.md に従って実装
4. **品質チェック**: review-comprehensive.md に従って確認
5. **コミット**: 適切なメッセージで変更をコミット
6. **プッシュ**: リモートブランチにプッシュ
7. **手動PR作成リンク提供**: 安全のため手動でPRを作成するためのリンクを提供
8. **PR作成の案内**: 手動でのPR作成手順を案内

### /quick の動作フロー

1. **現在ブランチで作業**: 新規ブランチ作成をスキップ
2. **実装**: 段階的実装
3. **コミット → プッシュ**: 連続実行

### /hotfix の動作フロー

1. **hotfix ブランチ作成**: `hotfix/[修正名]` ブランチ
2. **緊急修正**: 最小限の修正実装
3. **手動PR作成リンク提供**: 安全のため手動でPRを作成

## ワークフロー制御オプション

### 自動化レベル設定

- **"/dev --auto"** = 全ステップを自動実行（PR作成リンクまで）
- **"/dev --step"** = 各ステップで確認を求める（デフォルト）
- **"/dev --pause"** = 実装完了後に一時停止（手動で PR 作成）

### ブランチ命名規則

- 機能実装: `feature/[機能名]`
- バグ修正: `fix/[修正内容]`
- 緊急修正: `hotfix/[修正内容]`
- リファクタリング: `refactor/[対象]`

### 自動マージ条件

- [ ] 全テストパス
- [ ] コードレビュー承認（設定による）
- [ ] Conflict なし
- [ ] CI/CD パイプライン成功

## コミットメッセージ生成ルール

以下の形式で適切なコミットメッセージを生成：

### 機能追加

- `feat: ログイン機能を追加`
- `feat(auth): Firebase認証を実装`

### バグ修正

- `fix: ボタンクリック時のエラーを修正`
- `fix(ui): レスポンシブ表示の問題を解決`

### リファクタリング

- `refactor: HeaderComponentのスタイリングを改善`
- `refactor(types): 型定義を整理`

### ドキュメント

- `docs: READMEにセットアップ手順を追加`
- `docs(api): API仕様書を更新`

### その他

- `style: ESLintルールに従ってコードを修正`
- `test: ログイン機能のテストを追加`
- `chore: 依存関係を更新`

## デフォルト動作

実装系のタスクを依頼された場合、特に指示がなければ自動的に step-by-step-implementation.md に従って段階的に実装してください。

例：

- 「ログイン機能を作って」→ 自動的に段階的実装
- 「ボタンコンポーネントを作って」→ 自動的に figma-to-component.md 適用

## 高度な使用例

### フル開発ワークフロー

```
User: "/dev ログイン機能を実装"

Claude: "🚀 フル開発ワークフローを開始します

⚠️ 注意：Cursor Webのバックエンドインシデントにより、自動PR作成は一時停止中です

Step 1: ブランチ確認
現在: main ブランチ ✅
未コミット変更: なし ✅

Step 2: 作業ブランチ作成
feature/login-implementation を作成します

Step 3: 段階的実装開始
ログイン機能を以下の手順で実装：
□ ログインフォームUI作成
□ バリデーション機能追加
□ Firebase Auth連携
□ エラーハンドリング

最初のステップ（フォームUI）から始めますか？"
```

### チーム開発での使用

```
User: "/dev --step ユーザー認証機能 --reviewer @team-lead"
→ ステップ確認付きで実装、手動PR作成リンクを提供（@team-leadの情報を含む）

User: "/dev --auto 軽微なUIの調整"
→ 確認なしで実装、手動PR作成リンクを提供
```

### 複数機能の並行開発

```
User: "/dev 機能A && /dev 機能B"
→ 機能Aを完了後、feature/機能B ブランチで機能Bを開始（それぞれ手動PR作成リンク提供）
```

---

# 🔧 CI/CD パイプライン エラー対策 - 追加ルール

## 実装前必須チェック

すべての実装作業開始前に以下を**必ず実行**：

```bash
# 1. 依存関係の確認・修正
npm ci
npm audit fix

# 2. 既存コードの品質確認
npm run lint
npm run type-check
npm test

# 3. ビルド確認
npm run build
```

## 各段階での品質チェック

### 実装中のチェック（各ステップ後）

- [ ] TypeScript コンパイルエラーなし
- [ ] ESLint エラー・警告なし
- [ ] 未使用 import の削除
- [ ] console.log の削除

### コミット前必須チェック

- [ ] `npm run build` 成功
- [ ] `npm test` 全テスト通過
- [ ] `npm run lint` エラーゼロ
- [ ] `npm run type-check` 型エラーゼロ
- [ ] `npm audit` 重要な脆弱性なし

## エラー時の対処法

### ビルドエラーが発生した場合

```bash
# 1. 詳細なエラー情報を確認
npm run build -- --verbose

# 2. TypeScript型エラーの場合
npm run type-check -- --noEmit

# 3. 依存関係の問題の場合
npm ci
npm run build
```

### テストエラーが発生した場合

```bash
# 1. 詳細なテスト結果を確認
npm test -- --verbose

# 2. スナップショット更新が必要な場合
npm test -- --updateSnapshot

# 3. 特定のテストファイルのみ実行
npm test -- --testPathPattern=[ファイル名]
```

### リンターエラーが発生した場合

```bash
# 1. 自動修正可能なエラーを修正
npm run lint -- --fix

# 2. 手動修正が必要なエラーを確認
npm run lint -- --format=detailed
```

### セキュリティ脆弱性が発生した場合

```bash
# 1. 脆弱性の詳細を確認
npm audit

# 2. 自動修正を試行
npm audit fix

# 3. 強制更新（注意して実行）
npm audit fix --force
```

## 禁止事項（CI/CD 対策）

以下は CI/CD パイプラインでエラーの原因となるため**絶対に行わない**：

- [ ] TypeScript エラーがある状態でのコミット
- [ ] テストが失敗する状態でのコミット
- [ ] ESLint エラーがある状態でのコミット
- [ ] ビルドが失敗する状態でのコミット
- [ ] 重要な脆弱性があるパッケージの使用
- [ ] 環境変数の設定忘れ
- [ ] package.json と package-lock.json の不整合

## 推奨ワークフロー（CI/CD 対応版）

### 実装開始前

1. 最新の main ブランチに切り替え
2. `git pull origin main` で最新化
3. 事前品質チェック実行
4. 新しいブランチを作成

### 実装中

1. 小さな単位で実装
2. **各ステップ後に必ずビルド・テスト実行**
3. エラーが発生したら即座に修正
4. 段階的にコミット

### 実装完了後

1. 最終品質チェック実行
2. すべてのチェックが通過することを確認
3. 適切なコミットメッセージでコミット
4. プッシュ後、PR 作成

## トラブルシューティング

### よくあるエラーパターンと対処法

1. **"Module not found" エラー**

   ```bash
   # 解決方法
   rm -rf node_modules package-lock.json
   npm install
   ```

2. **"Type '...' is not assignable to type '...'" エラー**

   ```bash
   # 解決方法
   npm run type-check -- --noEmit
   # 型定義を修正後、再度確認
   ```

3. **"Expected 0 arguments, but got 1" エラー**

   ```bash
   # 解決方法
   # 関数の引数定義を確認・修正
   # TypeScript型定義を更新
   ```

4. **"Unexpected token" エラー**

   ```bash
   # 解決方法
   npm run lint -- --fix
   # 構文エラーを手動修正
   ```

5. **"Test suite failed to run" エラー**
   ```bash
   # 解決方法
   npm test -- --clearCache
   npm test
   ```

## 品質指標の目安

以下の指標を満たすことを推奨（現実的な範囲で）：

- **ビルド成功率**: 100%（必須）
- **TypeScript エラー**: 0 件（必須）
- **ESLint エラー**: 0 件（必須）
- **テスト成功率**: 100%（必須）
- **セキュリティ脆弱性**: 重要度 High 以上は 0 件（必須）
- **ビルド時間**: プロジェクト規模に応じて適切な範囲
- **テストカバレッジ**: 既存テストが通ること（新規テスト追加は推奨）

---

## 🤖 自動ドキュメント読み込みシステム

### 実装前の自動ドキュメント読み込み

すべての実装指示に対して、以下のフローを **自動実行** します：

#### 1. 指示内容の自動解析
指示に含まれるキーワードから関連ドキュメントを自動判定：

- **UI/デザイン関連**: `UI`, `コンポーネント`, `HeroUI`, `Button`, `Form`, etc.
- **セキュリティ関連**: `認証`, `auth`, `バリデーション`, `セキュリティ`, etc.
- **API関連**: `API`, `Firebase`, `Firestore`, `データベース`, etc.
- **リファクタリング関連**: `修正`, `改善`, `最適化`, `変更`, etc.

#### 2. 必須ドキュメントの自動読み込み

**🔴 全実装で必ず読み込み:**
- `docs/AI_IMPLEMENTATION_RULES.md` - AI実装の絶対ルール
- `DESIGN_GUIDELINE.md` - HeroUI・デザインルール（UI関連時）
- `.cursorrules` - 開発フロー（参照済みのため概要把握）

**🟡 カテゴリ該当時に読み込み:**
- `docs/SECURITY_IMPLEMENTATION.md` - セキュリティ実装ガイド
- `docs/REFACTORING_GUIDE.md` - リファクタリング手順
- `docs/components/component-catalog.md` - コンポーネント仕様
- `docs/api/README.md` - API実装ガイド

#### 3. 実装開始前の確認

読み込んだドキュメントの内容を踏まえて：
- 実装方針の確認
- 段階的実装計画の作成
- 禁止事項・制約の確認

### 自動実行例

**指示例**: "HeroUIのButtonを使ってログインフォームを作成"

**自動実行フロー**:
1. キーワード検出: `HeroUI`, `Button`, `フォーム`, `ログイン`
2. 自動読み込み: 
   - `docs/AI_IMPLEMENTATION_RULES.md`
   - `DESIGN_GUIDELINE.md` 
   - `docs/SECURITY_IMPLEMENTATION.md`
   - `docs/components/component-catalog.md`
3. ガイドライン準拠の実装計画作成
4. 実装実行

### メリット

- ✅ **指示の簡素化**: "〇〇のドキュメントに従って"と書く必要なし
- ✅ **ガイドライン準拠**: 自動でルール確認
- ✅ **一貫性向上**: すべての実装で同じ品質基準
- ✅ **効率化**: ドキュメント探索時間の短縮

**注意**: このシステムによって、今後は具体的な指示内容のみで十分な品質の実装が可能になります。

---

