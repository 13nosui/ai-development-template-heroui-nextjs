# Cursor開発ガイドライン - Project Template

## 基本方針
- **段階的実装**: タスクを小さな単位に分割して段階的に実装する
- **確認ベース**: 各ステップで動作確認を行ってから次に進む
- **単一責任**: 1つのタスクに集中し、複数機能を同時実装しない
- **CI/CD優先**: すべての変更は必ずCI/CDパイプラインを通してから提出

## PR作成・/devコマンド実行時の必須ルール
- すべての修正は、ビルド・テストが通る状態で、必ず差分が発生するPRとして提出すること。
- PR作成後は、必須チェック（GitHub Actions等）が完了し、pendingや失敗がないことを確認すること。
- コマンドや引数の記法は公式ドキュメントに従うこと。
- チェックがpendingの場合は、空コミット追加やPR再オープンで再実行を試みること。

## 🔧 CI/CDエラー対策 - 強化ルール

### 事前チェック必須項目
実装前に必ず以下を確認・実行：

```bash
# 1. 依存関係の確認
npm ls --depth=0
npm audit --audit-level=moderate

# 2. ビルド確認
npm run build

# 3. テスト実行
npm test
npm run test:coverage

# 4. リンター・フォーマッター
npm run lint
npm run format

# 5. 型チェック
npm run type-check
```

### Cursor Web /devコマンドへの指示内容
Cursor Webが/devコマンドを実行する際に従うべき指示：

**必須動作**: 以下を確認なしで順次自動実行し、エラーのないPR作成まで完了する

1. **自動環境準備**
   - 現在の変更を自動退避（git stash）
   - mainブランチ切替・最新化
   - feature/[タスク名]-[timestamp]ブランチ自動作成

2. **自動品質保証**
   - npm ci → npm audit fix --force
   - npm run lint -- --fix
   - npm run type-check
   - npm test --passWithNoTests
   - npm run build

3. **自動実装実行**
   - タスクを3-5ステップに自動分割
   - 各ステップ実装後に品質チェック実行
   - エラー検出時は自動修正を3回まで試行

4. **自動PR作成・マージ**
   - 適切なコミットメッセージで自動コミット
   - git push origin [branch-name]
   - gh pr create（タイトル・説明文自動生成）
   - GitHub Actions完了まで自動待機
   - 全チェック通過後に自動マージ（--squash --delete-branch）
   - mainブランチに自動復帰・最新化

**エラー処理**: いずれかの段階でエラーが発生した場合は自動修正を試行し、3回失敗したら停止

### CI/CDパイプライン対応コマンド

#### 新規追加コマンド
- **"/precheck"** = CI/CD実行前の事前チェック
- **"/fix-ci"** = CI/CDエラーの自動修正
- **"/build-test"** = ビルドとテストの組み合わせ実行
- **"/lint-fix"** = リンターエラーの自動修正
- **"/type-fix"** = TypeScript型エラーの修正
- **"/audit-fix"** = セキュリティ脆弱性の自動修正

#### 強化されたワークフローコマンド
- **"/dev-safe"** = 完全なCI/CDチェック付きワークフロー
- **"/dev-quick"** = 最小限チェック付きワークフロー
- **"/dev-hotfix"** = 緊急修正用の最適化ワークフロー

### エラー別対応マニュアル

#### 1. ビルドエラー対応
```bash
# TypeScript型エラー
npm run type-check -- --noEmit

# モジュール解決エラー
npm run build -- --verbose

# 依存関係エラー
npm ci
npm run build
```

#### 2. テストエラー対応
```bash
# 単体テスト失敗
npm test -- --verbose --coverage

# スナップショット更新
npm test -- --updateSnapshot

# テストファイル修正
npm test -- --watchAll=false
```

#### 3. リンターエラー対応
```bash
# 自動修正可能なエラー
npm run lint -- --fix

# 手動修正必要なエラー
npm run lint -- --format=detailed

# 設定ファイル確認
npm run lint -- --print-config
```

#### 4. セキュリティエラー対応
```bash
# 脆弱性スキャン
npm audit

# 自動修正
npm audit fix

# 強制更新（慎重に）
npm audit fix --force
```

## 📋 実装チェックリスト

### PR作成前必須チェック
- [ ] `npm run build` 成功
- [ ] `npm test` 全テスト通過
- [ ] `npm run lint` エラーゼロ
- [ ] `npm run type-check` 型エラーゼロ
- [ ] `npm audit` 重要な脆弱性なし
- [ ] 環境変数設定確認
- [ ] README.md更新（必要に応じて）
- [ ] CHANGELOG.md更新（必要に応じて）

### コード品質チェック
- [ ] 未使用import削除
- [ ] console.log削除
- [ ] TODOコメント整理
- [ ] 適切なエラーハンドリング
- [ ] 型定義の完全性
- [ ] アクセシビリティ対応
- [ ] レスポンシブデザイン確認
- [ ] パフォーマンス最適化

### テスト要件
- [ ] 新機能のテストケース作成
- [ ] エッジケースのテスト
- [ ] エラーケースのテスト
- [ ] 統合テストの更新
- [ ] テストカバレッジ90%以上

## 🚀 強化されたワークフロー

### /dev-safe の詳細動作
```bash
# 1. 環境確認
git status
node --version
npm --version

# 2. 依存関係確認
npm ci
npm audit

# 3. 事前テスト
npm run lint
npm run type-check
npm test

# 4. ビルド確認
npm run build

# 5. ブランチ作成
git checkout -b feature/[機能名]

# 6. 段階的実装
# step-by-step-implementation.mdに従って実装

# 7. 各段階でのテスト
npm run build && npm test

# 8. 最終チェック
npm run lint -- --fix
npm run type-check
npm test -- --coverage
npm run build

# 9. コミット
git add .
git commit -m "適切なコミットメッセージ"

# 10. プッシュ
git push origin feature/[機能名]

# 11. PR作成
gh pr create --title "..." --body "..."

# 12. CI/CD待機
# GitHub Actionsの完了を待つ
```

### /precheck の動作
```bash
echo "🔍 CI/CD事前チェック開始..."

# Node.js環境確認
node --version
npm --version

# パッケージ整合性確認
npm ls --depth=0

# 脆弱性チェック
npm audit --audit-level=moderate

# 型チェック
npm run type-check

# リンター実行
npm run lint

# テスト実行
npm test

# ビルド確認
npm run build

echo "✅ 事前チェック完了"
```

### /fix-ci の動作
```bash
echo "🔧 CI/CDエラー自動修正開始..."

# 依存関係修正
npm ci

# リンターエラー修正
npm run lint -- --fix

# 型エラー確認
npm run type-check --noEmit

# 脆弱性修正
npm audit fix

# テスト実行
npm test

# ビルド確認
npm run build

echo "✅ CI/CDエラー修正完了"
```

## 🎯 個人開発特化設定

### 自動化レベル設定
```bash
# 完全自動化（推奨）
/dev-safe --auto

# 段階確認付き
/dev-safe --step

# 最小限チェック
/dev-quick --minimal
```

### ブランチ戦略（個人開発）
- **main**: 本番環境
- **develop**: 開発環境（省略可能）
- **feature/***: 機能開発
- **hotfix/***: 緊急修正

### 自動マージ条件（個人開発）
- [ ] 全テストパス
- [ ] ビルド成功
- [ ] リンターエラーゼロ
- [ ] 型エラーゼロ
- [ ] 脆弱性なし

## 📊 品質指標

### 必須指標
- **テストカバレッジ**: 90%以上
- **ビルドサイズ**: 3MB以下
- **ロード時間**: 2秒以下
- **Lighthouse Score**: 90点以上
- **脆弱性**: 0件

### 監視項目
- Bundle size変更
- 依存関係更新
- パフォーマンス指標
- エラー発生率

## 🔄 継続的改善

### 週次レビュー
- [ ] 依存関係更新
- [ ] 脆弱性スキャン
- [ ] パフォーマンス測定
- [ ] コード品質確認

### 月次レビュー
- [ ] アーキテクチャ見直し
- [ ] テスト戦略見直し
- [ ] CI/CD最適化
- [ ] ドキュメント更新

## 🚨 エラー対応フローチャート

```
エラー発生
    ↓
ビルドエラー? → Yes → 型チェック → 修正 → 再ビルド
    ↓ No
テストエラー? → Yes → テスト詳細確認 → 修正 → 再テスト
    ↓ No
リンターエラー? → Yes → 自動修正実行 → 手動修正 → 再実行
    ↓ No
依存関係エラー? → Yes → npm ci → npm audit → 修正
    ↓ No
その他 → ログ確認 → 個別対応
```

## 💡 トラブルシューティング

### よくあるエラーと対処法

1. **"Module not found"**
   ```bash
   npm ci
   npm run build
   ```

2. **"Type error"**
   ```bash
   npm run type-check -- --noEmit
   # 型定義修正後
   npm run build
   ```

3. **"Test failed"**
   ```bash
   npm test -- --verbose
   # テスト修正後
   npm test
   ```

4. **"Build failed"**
   ```bash
   npm run build -- --verbose
   # エラー箇所修正後
   npm run build
   ```

5. **"Audit vulnerabilities"**
   ```bash
   npm audit fix
   # 手動修正が必要な場合
   npm audit fix --force
   ```

## 実装の進め方（強化版）
1. **事前確認**: `/precheck` コマンドでCI/CD事前チェック
2. **環境準備**: 依存関係とビルド環境の確認
3. **小単位実装**: 1つの機能につき1つのファイルまたはコンポーネントに集中
4. **段階確認**: 各段階でビルド・テスト・リンターを実行
5. **品質確認**: コードレビューとテストカバレッジ確認
6. **CI/CD確認**: GitHub Actionsの完了を待機

## 禁止事項（強化版）
- CI/CDチェックをスキップする
- テストを書かずに実装する
- 型エラーを無視する
- リンターエラーを無視する
- 脆弱性のあるパッケージを使用する
- ビルドが失敗する状態でコミットする
- 複数ファイルの同時大幅変更
- 未確認のまま次の機能に進む
- 全体的なリファクタリングを一度に行う

## 🤖 完全自動化 /devコマンド設定

### Cursor Web /devコマンドの完全自動化動作
`/dev [タスク内容]` 実行時は以下を**確認なしで全自動実行**：

```bash
# ===== PHASE 1: 環境準備 =====
echo "🚀 /dev完全自動化開始: [タスク内容]"

# 1-1. 現在状態確認
git status --porcelain
git branch --show-current

# 1-2. 未コミット変更がある場合は自動退避
if [ -n "$(git status --porcelain)" ]; then
  git stash push -m "auto-stash-before-dev-$(date +%s)"
fi

# 1-3. mainブランチに切り替え＆最新化
git checkout main
git pull origin main

# ===== PHASE 2: 事前品質チェック =====
# 2-1. 依存関係確認＆修正
npm ci
npm audit fix --force

# 2-2. 既存コードの品質確認
npm run lint -- --fix
npm run type-check
npm test --passWithNoTests

# 2-3. ビルド確認
npm run build

# ===== PHASE 3: 作業ブランチ作成 =====
# 3-1. ブランチ名自動生成
BRANCH_NAME="feature/$(echo '[タスク内容]' | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')-$(date +%s)"
git checkout -b $BRANCH_NAME

# ===== PHASE 4: 実装実行 =====
# 4-1. タスクを3-5個のステップに自動分割
# 4-2. 各ステップを順次実装
# 4-3. 各ステップ後に自動品質チェック実行

# ===== PHASE 5: 品質保証ループ =====
# 5-1. 実装後の品質チェック
npm run lint -- --fix
npm run type-check --noEmit
npm test --coverage --watchAll=false

# 5-2. エラーがある場合は自動修正試行
while ! npm run build > /dev/null 2>&1; do
  echo "🔧 ビルドエラー検出 - 自動修正中..."
  # TypeScriptエラー自動修正
  npm run type-check -- --noEmit --pretty
  # 一般的なエラーパターンの修正実行
  npm run lint -- --fix
  
  # 3回試行して失敗したら中断
  RETRY_COUNT=$((RETRY_COUNT + 1))
  if [ $RETRY_COUNT -gt 3 ]; then
    echo "❌ 自動修正に失敗しました"
    exit 1
  fi
done

# ===== PHASE 6: 最終検証 =====
echo "✅ 最終検証実行中..."
npm run lint
npm run type-check
npm test --coverage --watchAll=false
npm run build
npm audit --audit-level=moderate

# ===== PHASE 7: コミット＆プッシュ =====
# 7-1. 変更内容を解析して適切なコミットメッセージ生成
COMMIT_MSG="feat: [タスク内容の要約]

- [実装した機能1]
- [実装した機能2]
- [修正した問題]

Automated PR via /dev command"

# 7-2. 全変更をコミット
git add .
git commit -m "$COMMIT_MSG"

# 7-3. リモートにプッシュ
git push origin $BRANCH_NAME

# ===== PHASE 8: PR自動作成 =====
# 8-1. PR説明文自動生成
PR_BODY="## 概要
[タスク内容]を実装しました。

## 実装内容
- [具体的な実装内容]
- [変更したファイル]
- [追加したテスト]

## テスト結果
- ✅ ビルド成功
- ✅ 全テスト通過
- ✅ リンターエラーなし
- ✅ 型チェック通過
- ✅ 脆弱性なし

## 確認事項
- [ ] 機能動作確認
- [ ] レスポンシブ確認
- [ ] アクセシビリティ確認

Automated PR created by Cursor /dev command
$(date)"

# 8-2. GitHub PR作成
gh pr create \
  --title "feat: [タスク内容]" \
  --body "$PR_BODY" \
  --base main \
  --head $BRANCH_NAME \
  --assignee @me

# ===== PHASE 9: CI/CD監視＆自動マージ =====
echo "🔄 CI/CDパイプライン監視中..."

# 9-1. GitHub Actions完了まで待機
PR_NUMBER=$(gh pr view --json number --jq .number)
while true; do
  STATUS=$(gh pr view $PR_NUMBER --json statusCheckRollup --jq '.statusCheckRollup[].state' | sort | uniq)
  
  if echo "$STATUS" | grep -q "FAILURE\|ERROR"; then
    echo "❌ CI/CDパイプラインでエラーが発生しました"
    echo "PR URL: $(gh pr view $PR_NUMBER --json url --jq .url)"
    exit 1
  elif [ "$STATUS" = "SUCCESS" ]; then
    echo "✅ 全てのCI/CDチェックが成功しました"
    break
  else
    echo "⏳ CI/CDパイプライン実行中... (30秒後に再確認)"
    sleep 30
  fi
done

# 9-2. 自動マージ実行
gh pr merge $PR_NUMBER --squash --delete-branch

# ===== PHASE 10: 完了処理 =====
# 10-1. mainブランチに戻る
git checkout main
git pull origin main

# 10-2. 完了報告
echo "🎉 /dev完全自動化完了!"
echo "📝 実装内容: [タスク内容]"
echo "🔗 PR: $(gh pr view $PR_NUMBER --json url --jq .url)"
echo "✅ 自動マージ完了"
echo "🚀 mainブランチが最新状態に更新されました"
```

### 自動化レベル設定
```bash
# デフォルト: 完全自動化（推奨）
/dev "ログイン機能を実装"

# 確認ステップあり（デバッグ用）
/dev --confirm "ログイン機能を実装"

# 手動マージ（PR作成まで自動）
/dev --no-merge "ログイン機能を実装"
```

### エラー時の自動復旧機能
```bash
# ビルドエラー自動修正
auto_fix_build_errors() {
  echo "🔧 ビルドエラー自動修正中..."
  
  # TypeScript型エラー修正
  npm run type-check -- --noEmit | grep "error TS" | while read error; do
    # 一般的な型エラーパターンの自動修正
    echo "修正中: $error"
  done
  
  # 未使用import削除
  npm run lint -- --fix
  
  # 再ビルド試行
  npm run build
}

# テストエラー自動修正
auto_fix_test_errors() {
  echo "🔧 テストエラー自動修正中..."
  
  # スナップショット更新
  npm test -- --updateSnapshot --watchAll=false
  
  # 再テスト実行
  npm test --watchAll=false
}

# 依存関係エラー自動修正
auto_fix_dependency_errors() {
  echo "🔧 依存関係エラー自動修正中..."
  
  # 強制再インストール
  rm -rf node_modules package-lock.json
  npm install
  
  # 脆弱性修正
  npm audit fix --force
}
```

## デフォルト動作（完全自動化版）
**すべての実装系タスクは/devコマンドで完全自動化**：

1. **環境準備**: 自動でmainブランチ最新化、作業ブランチ作成
2. **実装**: タスクを自動分割して段階的実装
3. **品質保証**: エラー検出時の自動修正試行
4. **PR作成**: 適切なタイトル・説明文で自動PR作成
5. **CI/CD監視**: GitHub Actions完了まで自動待機
6. **自動マージ**: 全チェック通過後に自動でmainにマージ
7. **後処理**: mainブランチに戻って最新状態に更新

例：
- 「ログイン機能を作って」→ 完全自動でPR作成・マージまで実行
- 「バグを修正して」→ 自動で修正・テスト・マージまで実行
- 「UIを改善して」→ 自動で実装・品質チェック・マージまで実行

---
*この強化版ルールにより、CI/CDパイプラインでのエラーを大幅に削減し、個人開発でも enterprise-grade な品質を維持できます。*
